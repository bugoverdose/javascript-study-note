## 가변값

참조형 데이터는 객체의 변수(property) 영역이 별도로 존재.
데이터 영역에 저장된 값들은 모두 불변값이지만, 변수 영역들에는 다른 값 대입 가능.

### (1) 참조형 데이터의 변수 할당

```javascript
var obj1 = {
  a: 1,
  b: "bbb",
};
```

- 변수 영역1(@1002): 식별자: obj1 / 값: @5001
- 데이터 영역1(@5001): @7001, @7002 ~
- 데이터 영역2(@5002): 1
- 데이터 영역3(@5003): 'bbb'

- 객체@5001의 변수(property) 영역1(@7001): 식별자:a / 값: @5002
- 객체@5001의 변수 영역2(@7002): 식별자:b / 값: @5003

실행결과

1. 비어있는 메모리 공간 중 하나를 확보. 변수 영역(@1002)의 식별자는 'obj1'로 지정.

1-1) 객체 데이터 영역1(@5001) + property들의 데이터 영역(@5002, @5003) 확보.

2. 객체 데이터 영역(@5001)은 변수 영역들 확보(@7001, @7002 ~ )

- 객체의 property들을 저장하기 위한 메모리 영역은 크기 미정. 필요한 시점에 동적으로 메모리 확보.

3. @7001, @7002에 각각 property 이름(a, b) + 데이터 영역의 주소 @5002, @5003 지정.

---

### (2) 참조형 데이터의 property 재할당

```javascript
var obj1 = {
  a: 1,
  b: "bbb",
};
obj1.a = 2;
```

- 변수 영역1(@1002): 식별자: obj1 / 값: @5001 [불변]
- 데이터 영역1(@5001): @7001, @7002 ~
- 데이터 영역2(@5002): 1
- 데이터 영역3(@5003): 'bbb'
- 데이터 영역4(@5004): '2' [새롭게 생성]

- 객체@5001의 변수(property) 영역1(@7001): 식별자:a / 값: @5002 => @5004
- 객체@5001의 변수 영역2(@7002): 식별자:b / 값: @5003

1. 객체 obj1는 여전히 @5001을 가리킴. 새로운 객체가 만들어지지 않았음.
2. 객체 내부의 property만 다른 값을 가리키게 됨. (객체 내부의 값만 변화)

---

중첩 객체 nested Object

### (3) 중첩된 참조형 데이터의 property 할당

```javascript
var obj = {
  x: 3,
  arr: [3, 4, 5],
};
```

- 변수 영역(@1002): 식별자: obj / 값: @5001
- 데이터 영역1(@5001): @7001, @7002 ~
- 데이터 영역2(@5002): 3
- 데이터 영역3(@5003): @8001, @8002, @8003 ~
- 데이터 영역4(@5004): 4
- 데이터 영역5(@5005): 5

- 객체@5001의 변수 영역1(@7001): 식별자:x / 값: @5002
- 객체@5001의 변수 영역2(@7002): 식별자:arr / 값: @5003

- 배열@5003의 변수 영역1(@8001): 식별자:0 / 값: @5002
- 배열@5003의 변수 영역2(@8002): 식별자:1 / 값: @5004
- 배열@5003의 변수 영역3(@8003): 식별자:2 / 값: @5005

---

(3-1) obj.arr[1] 검색 과정

- obj : obj라는 식별자의 주소 탐색(@1002)
  - @1002의 값인 주소로 이동(@5001)
  - @5001의 값인 주소들로 이동(@7001, @7002 ~)
- obj.arr : arr이라는 식별자의 주소 탐색(@7002)
  - @7002의 값인 주소로 이동(@5003)
  - @5003의 값인 주소들로 이동(@8001, @8002, @8003 ~)
- obj.arr[1] : index=1에 해당하는 주소 탐색(@8002)
  - @8002의 값인 주소로 이동(@5004)
  - @5004의 값인 숫자형 데이터 4 반환.

---

(3-2) obj.arr = "str" 재할당 과정

```javascript
obj = {
  x: 3,
  // arr: [3, 4, 5] // before
  arr: "str", // after
};
```

- 변수 영역(@1002): 식별자: obj / 값: @5001
- 데이터 영역1(@5001): @7001, @7002 ~
- 데이터 영역2(@5002): 3
- **데이터 영역3(@5003): @8001, @8002, @8003 ~ [GC 수거 대상]**
- 데이터 영역4(@5004): 4
- 데이터 영역5(@5005): 5
- 데이터 영역6(@5006): 'str'

- 객체@5001의 변수 영역1(@7001): 식별자:x / 값: @5002
- 객체@5001의 변수 영역2(@7002): 식별자:arr / **값: @5003 => @5006**

- **배열@5003의 변수 영역1(@8001): 식별자:0 / 값: @5002 [GC 수거 대상]**
- **배열@5003의 변수 영역2(@8002): 식별자:1 / 값: @5004 [GC 수거 대상]**
- **배열@5003의 변수 영역3(@8003): 식별자:2 / 값: @5005 [GC 수거 대상]**

실행결과

- @5003, @8001, @8002, @8003 모두 참조 카운트=0 => [GC 수거 대상]이 됨

---

cf) **참조 카운트**: 자신의 주소를 참조하고 있는 변수의 개수. (데이터 영역 기준)
참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됨.

garbage collector(이하 GC)는 메모리 사용량이 포화 상태에 임박할 때마다
혹은 런타임 환경에 따라 특정 시점마다 자동으로 수거 대상의 메모리들을 수거.
수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 됨.
