## 결론: 함수 표현식을 사용하자.

**익명함수**를 **변수에 할당**하는 것이 가장 이상적.

```javascript
const a = function (x, y) {
  return x + y;
};
const b = (x, y) => x + y;
b(1, 2); // 출력: 3
```

## 함수를 정의하는 방법들

- `함수 선언문 function declaration` : **함수 전체가 호이스팅됨**. 위험.

  - 함수 정의부만 존재. 별도의 할당 명령이 없는 경우.
  - 반드시 함수명이 정의되어 있어야 함.

- `함수 표현식 function expression` : **변수 선언 부분만 호이스팅**. 안전.

  - 함수를 정의하고 **별도의 변수에 할당**한 경우.
  - 함수명을 정의해도, 정의하지 않아도 됨.
    - **익명 함수 표현식: 함수명을 정의하지 않고 변수에 할당하는 경우**
      (비교) 기명 함수 표현식: 변수명과 함수명이 서로 다름. 사용 지양.

## 함수를 정의하는 3가지 방법 - 사실상 2가지

```javascript
// (1) 함수 선언문. a는 함수명이자 변수명.
function a() {} // 식별자(변수명)을 호이스팅하면서 전체가 올라감!

// (2) 익명 함수 표현식. b는 변수명이자 함수명.
var b = function () {};

// (3) 기명 함수 표현식. 변수명 c, 함수명 d. => BAD!
var c = function d() {};
c(); // 실행 가능.
d(); // 에러 발생.
```

기명 함수 표현식의 경우 외부에서는 할당된 변수명으로만 해당 함수 호출 가능.
함수명은 해당 함수 내부에서 접근할 때, 즉 재귀함수 호출 용도로만 사용 가능

```javascript
// 원문 코드
console.log(sum(1, 2)); // 출력: 3
console.log(mult(3, 4)); // Uncaught TypeError: mult is not a function

function sum(a, b) {
  return a + b; // 함수 선언문 => sum이 호이스팅됨!
}
var mult = function (a, b) {
  return a * b; // 함수 표현식
};
```

```javascript
// 위의 코드에서 hoisting을 마친 직후의 상태
function sum(a, b) {
  return a + b; // 함수 선언문은 전체를 호이스팅
}
var mult; // 변수를 선언하는 부분만 호이스팅

console.log(sum(1, 2)); // 출력: 3
console.log(mult(3, 4)); // Uncaught TypeError: mult is not a function

mult = function (a, b) {
  return a * b; // 변수에 함수 표현식을 할당하는 부분은 기존 위치에.
};
```

---

## 정리

함수 정의 이전에 해당 함수를 호출하는 경우,

- **함수 선언문은 함수 전체를 호이스팅했기 때문에 미리 호출 가능.**
- 함수 표현식은 변수 선언 부분만 호이스팅하고, 변수에 함수 내용을 할당하는 부분은 기존 위치에 그대로 남겨놓음. 함수의 내용이 없기 때문에 에러 발생.

### 함수 선언문의 위험성

**함수를 선언하기 이전인데도 호출할 수 있다는 점**에서 오히려 함수 선언문이 **위험함**. NOT 편리함.

ex) `실수로 동명의 함수를 다른 곳에서 중복 선언한 경우`, 전역 컨텍스트가
활성화될 때 전역공간에 선언된 모든 함수들을 위로 끌어올리게 됨.

- 함수 선언문이었다면` 마지막으로 선언한 내용이 함수명을 덮어쓰고(override)`, 모든 곳에 의도치 않은 영향을 미치게 되지만 에러는 발생하지 않음.
- 함수 표현식이었다면 변수 선언 부분만 끌어올려지고, 변수에 함수의 내용을 할당하는 부분은 기존 위치에 그대로 존재하므로, **코드의 흐름에 따라 순차적으로 덮어쓰여지면서 사용됨**. (의도대로 실행됨)
